#!/usr/bin/env perl

use strict;
use warnings;
use utf8;
use Getopt::Std;

no warnings 'utf8';

my $USAGE = <<"USAGE";
Usage: srttidy [OPTIONS] SRT-FILE [...]
   or: srttidy [OPTIONS] < IN-SRT-FILE > OUT-SRT-FILE

Options
  -m DURATION,GAP       change timestamps by given minimum duration and gap 
                        in seconds
  -c COLOR              specify default subtitle font color
  -r                    remove specified font color
  -n                    delete empty subtitles, and reorder them one-by-one
  -d PATTERNS           delete subtitles empty or including given patterns,
                        and reorder them one-by-one
  -s SECOND             shift timestamps by given seconds
  -l TIME-MAP           correct timestamps linearly by given time map
  -t                    display subtitle texts only

Examples
  srttidy -m 1.0,0.1 my.srt
  srttidy -c silver *.srt
  srttidy -r < old.srt > new.srt
  srttidy -d yts,sub2smi,elsubtitle *.srt
  srttidy -n Movies/*/*.srt
  srttidy -s -8.26 < old.srt > new.srt
  srttidy -t < my.srt > my.txt
  srttidy -l "00:00:19,145->00:00:22,189 02:39:17,715->02:39:18,390" my.srt

See <https://github.com/9beach/srt-tools> for updates and bug reports
USAGE

my $QR_BOM = qr/\xEF\xBB\xBF/;
my $QR_DECIMAL = qr/[+-]?\d+\.?\d*/;
my $QR_TIME = qr/[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]/;
my $QR_DURATION = qr/${QR_TIME} *--> *${QR_TIME} *\r?\n/;
my $QR_TIMEMAP = qr/${QR_TIME}->${QR_TIME} +${QR_TIME}->${QR_TIME}/;

sub say { print STDERR shift."\n"; }

my %opts = ();

# Checks the constraints of opts
die $USAGE unless getopts("tm:c:rd:nl:s:h", \%opts);
die $USAGE if $opts{h};
die $USAGE if (-t STDIN and $#ARGV < 0) or (not -t STDIN and $#ARGV >= 0);
die "Cannot use both -c and -r at the same time\n" if defined $opts{c}
    and defined $opts{r};
die "Cannot use both -s and -l at the same time\n" if defined $opts{s}
    and defined $opts{l};
die "Cannot use -s or -l with multiple files\n" if $#ARGV > 0
    and (defined $opts{s} or defined $opts{l});
die "'$opts{l}' is not valid time-map format\n" if defined $opts{l}
    and not $opts{l} =~ /^${QR_TIMEMAP}$/;
die "'$opts{s}' is not a decimal number\n" if defined $opts{s}
    and not $opts{s} =~ /^${QR_DECIMAL}$/;
die "Cannot use -t with the other options\n" if defined $opts{t}
    and (scalar keys %opts > 1);

# Reads from pipe
if ($#ARGV < 0) {
    my $content; { local $/; $content = <STDIN> };

    $content = tidy(conv($content), %opts);
    die "invalid content\n" if $content eq "";
    print $content;

    exit 0;
}

my $err = 0;

# Reads ARGV files
foreach my $srt (@ARGV) {
    my $nsrt = $srt; $nsrt =~ s/\.[^\/\.]*$//;
    if (not defined $opts{t}) {
        $nsrt .= "-tidy.srt" ;
    } else {
        $nsrt .= "-tidy.txt" ;
    }

    unless (open(SRT, '<', $srt)) {
        $err = -1;
        say "failed to open: ${srt}";
        next;
    }
    unless (open(NSRT, '>', $nsrt)) {
        $err = -1;
        say "failed to open: ${nsrt}";
        close(SRT);
        next;
    }
    my $content; { local $/; $content = <SRT> };

    # Shows file name on analysis
    say "tidying: $nsrt" if (defined $opts{m});

    $content = tidy(conv($content), %opts);
    if ($content eq "") {
        $err = -1;
        say "invalid content: ${srt}";
        close(SRT);
        close(NSRT);
        unlink $nsrt;
    } else {
        say "created: ${nsrt}";
        print NSRT $content;
        close(SRT);
        close(NSRT);
    }
}

exit $err;

# Defines submodules below

# Processes the commands
sub tidy {
    my $content = shift;
    my $opts = shift;

    # Checks if valid SubRip
    return "" if $content !~ /^(${QR_BOM})?[0-9]+\s*\n\s*${QR_DURATION}\s*/m;

    # Deletes dialogues empty or including given patterns
    if (defined $opts{d}) {
        # \x08, \x09: boundary delimiters for text replacement
        $content =~ s/^(${QR_BOM})?([0-9]+)\s*(\r?\n)\s*(${QR_DURATION})
                    /\x08$2$3$4\x09/xgm;
        my @patterns = split ",", $opts{d};
        foreach (@patterns) {
            # Removes dialog in boundary delimiters if they include pattern
            $content =~ s/\x08[^\x08]*\x09[^\x08\x09]*$_[^\x08]*//gmi;
        }
        $content =~ tr/\x08\x09\r//d;
    }

    # Removes orders and timestamps having blank dialogues
    if (defined $opts{n}) {
        my $order = 0;
        for ($content) {
            # Removes black lines
            s/^\s*(\r?\n)+//gm;
            # Inserts line before each order
            s/(.)(\r?\n)([0-9]+\s*\n${QR_TIME} *-->)/$1$2$2$3/gm;
            # Removes order and timestamp with blank text
            s/^(${QR_BOM})?[0-9]+\s*\n${QR_DURATION}((\r?\n)+|\z)//gm;
            # Removes additional '\n' when final subtitle was empty
            s/(\r?\n)+\z/$1/m;
            # Reorders one by one
            s/^(${QR_BOM})?[0-9]+\s*(\r?\n${QR_DURATION})/${\++$order}$2/gm;
        }
    }

    # Displays subtitle texts only
    if (defined $opts{t}) {
        # \x08, \x09: boundary delimiters for text replacement
        $content =~ s/^(${QR_BOM})?([0-9]+)\s*(\r?\n)\s*(${QR_DURATION})//gm;
        $content =~ s/\s*(\r?\n)\s*/$1/gm;
        $content =~ s/<\/? *[a-zA-Z]*[^>]*>//gm;

        # Not srt so return
        return $content;
    }
 
    # Deletes dialogues empty or including given patterns
    if (defined $opts{d}) {
        # \x08, \x09: boundary delimiters for text replacement
        $content =~ s/^(${QR_BOM})?([0-9]+)\s*(\r?\n)\s*(${QR_DURATION})
                    /\x09$2$3$4\x08/xgm;
        my @patterns = split ",", $opts{d};
        foreach (@patterns) {
            # Removes dialog in boundary delimiters if they include pattern
            $content =~ s/\x08[^\x09\x08]*$_[^\x09\x08]*/\x08\x09/gmi;
        }
        $content =~ tr/\x09\x08//d;
    }

    # Specifies default font color
    if (defined $opts{c}) {
        $content =~ s/<font color[^>]* x=keep-it>//g;
        $content =~ s/(^${QR_DURATION})([^\r\n])
                    /$1<font color=$opts{c} x=keep-it>$2/xgm;
    }

    # Resets specified font colors
    if (defined $opts{r}) {
        $content =~ s/<font color[^>]* x=keep-it>//g;
    }

    # Shift timestamps
    if (defined $opts{s}) {
        unless ($opts{s} =~ /^${QR_DECIMAL}$/) {
            die "'$opts{s}' is not a decimal number\n";
        }
        my $sec = $opts{s};
        $content =~ s/(${QR_TIME})[[:blank:]]*-->[[:blank:]]*(${QR_TIME})
                    /${\s_shift($1, $sec)} --> ${\s_shift($2, $sec)}/xg;
    }

    # Corrects timestamps linearly
    if (defined $opts{l}) {
        my ($a, $b) = slope_intercept($opts{l});
        $content =~ s/(${QR_TIME})[[:blank:]]*-->[[:blank:]]*(${QR_TIME})
                    /${\l_shift($1, $a, $b)} --> ${\l_shift($2, $a, $b)}/xg;
    }

    # Changes timestamps by given minimum duration and gap, and reports them
    if (defined $opts{m}) {
        my ($md, $mg) = split(",", $opts{m});
        my $ncontent = "";

        for ($content) {
            # Dummy for last element
            s/\s*\z/\n1000000\n99:00:00,000 --> 99:59:59,000\ndummy/m;
            # \x09: delimiter for each (order + timestamp + dialog)
            s/^(${QR_BOM})?([0-9]+)\s*(\r?\n)\s*(${QR_DURATION})/\x09$2$3$4/gm;
        }

        my ($porder, $pfrom, $pfrom_s, $pto, $pto_s, $pdialog) = ("");

        # Iterates for each delimiter
        while ($content =~ /
                \x09([0-9]+)\s*(\r?\n)(${QR_TIME})[[:blank:]]*-->[[:blank:]]*
                (${QR_TIME}).*\r?\n([^\x09]*)/xgm) {
            my (
                $order, $from, $from_s, $to, $to_s, $dialog
            ) = ($1, $3, to_s($3), $4, to_s($4), $5);

            unless ($porder eq "") {
                $ncontent .= analyze (
                    ($porder, $pfrom, $pfrom_s, $pto, $pto_s, $pdialog),
                    ($order, $from, $from_s, $to, $to_s, $dialog),
                    ($md, $mg),
                );
            }
            ($porder, $pfrom, $pfrom_s, $pto, $pto_s, $pdialog) =
                ($order, $from, $from_s, $to, $to_s, $dialog);
        }

        $content = $ncontent;
    }

    return $content;
}

sub analyze {
    my (
        $porder, $pfrom, $pfrom_s, $pto, $pto_s, $pdialog,
        $order, $from, $from_s, $to, $to_s, $dialog,
        $md, $mg,
    ) = @_;

    my $pduration = $pto_s - $pfrom_s;

    # Checks if duration is short, or timestamps are overlapped
    if ($pduration < $md or $pto_s > $from_s) {
        my $state = 'SHORT';
        $state = 'OVERLAPPED' if $pto_s > $from_s;

        my $new_pto_s = 0;

        if ($pfrom_s + $md + $mg < $from_s) {
            if ($state eq 'SHORT') {
                $new_pto_s = $md + $pfrom_s;
            } else {
                $new_pto_s = $from_s - $mg;
            }
            $state .= '/FIXED';
        } elsif ($pto_s + $mg < $from_s) {
            $new_pto_s = $from_s - $mg;
            $state .= '/FIXED BUT SHORT';
        }

        my $sduration;
        if ($new_pto_s) {
            $sduration =
                sprintf('%.3f -> %.3f', $pduration, $new_pto_s - $pfrom_s);
        } else {
            $sduration = sprintf('%.3f', $pduration);
        }

        say_tidy_info(
            $porder,
            "$state ($sduration))",
            "$pfrom --> $pto\n$pdialog",
        );

        if ($new_pto_s) {
            $pto_s = $new_pto_s;
            $pto = to_hms($pto_s * 1000);
        }
    }
    return "$porder\n$pfrom --> $pto\n$pdialog";
}

sub say_tidy_info {
    say '* '.shift.': '.shift;
    my $dialog = shift;
    $dialog =~ s/^/  /mg;
    $dialog =~ s/\s*\z/\n/m;
    say $dialog;
}

# Gets slope $a and intercept $b for y = ax + b
sub slope_intercept {
    my $opt = shift;
    my @m = split(/  */, $opt);
    my @t1 = split("->", $m[0]);
    my @t2 = split("->", $m[1]);
    my $t11 = to_s($t1[0]);
    my $t12 = to_s($t1[1]);
    my $t21 = to_s($t2[0]);
    my $t22 = to_s($t2[1]);
    my $a = ($t22 - $t12) / ($t21 - $t11);
    my $b = $t12 - $a * $t11;

    return ($a, $b);
}

# Below, defines submodules
sub s_shift {
    my $t = shift;
    my $s = shift;

    return to_hms((to_s($t) + $s) * 1000);
}

sub l_shift {
    my $t = shift;
    my $a = shift;
    my $b = shift;

    return to_hms((to_s($t) * $a + $b) * 1000);
}

# Decodes to UTF-8
sub conv {
    my $buf = shift;
    my $hd = substr $buf, 0, 1280;

    if (not utf8::decode $hd) {
        require Encode;
        require Encode::Guess;

        my $decoder = Encode::Guess::guess_encoding($buf, qw/cp949 euc-kr/);
        if (ref($decoder)) {
            $buf = $decoder->decode($buf);
        } else {
            # Fairly often it works
            $buf = Encode::decode("CP949", $buf);
        }
    }
    $buf =~ tr/\r//d;

    return $buf;
}

sub to_s {
    my $fmt = shift;
    $fmt =~ s/,/./;
    my @hms = split(":", $fmt);
    return $hms[0] * 3600 + $hms[1] * 60 + $hms[2];
}

sub to_hms {
    my $millisec = shift;
    $millisec = 0 if ($millisec < 0);

    my $seconds = $millisec / 1000;
    my $ms = $millisec % 1000;
    my $s = $seconds % 60;
    my $m = ($seconds / 60) % 60;
    my $h = ($seconds / 3600) % 60;

    return sprintf("%02d:%02d:%02d,%03d", $h, $m, $s, $ms);
}
