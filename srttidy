#!/usr/bin/env perl -CA

use strict;
use warnings;
use utf8;
use Getopt::Std;
no warnings 'utf8';

my $USAGE = <<"USAGE";
Usage: srttidy [OPTIONS] SRT-FILE [...]
   or: srttidy [OPTIONS] < IN-SRT-FILE > OUT-SRT-FILE

Options
  -t                    show subtitle texts only
  -c COLOR              specify default subtitle font color
  -r                    remove specified font color
  -s SECOND             shift timestamps by given time in seconds
  -l TIME-MAP           correct timestamps linearly by given time map
  -n                    remove empty subtitles, and reorder lefts one-by-one
  -d PATTERN            remove subtitles including given pattern
  -g PATTERN            show subtitles including given pattern
  -m DURATION,GAP       change timestamps by given minimum duration and gap 
                        in seconds
  -f CONDITION          show or apply -m option only to subtitles matching
                        given condition
  -b                    remove carriage returns and BOM

Examples
  srttidy -t < my.srt > my.txt
  srttidy -c silver *.srt
  srttidy -r < old.srt > new.srt
  srttidy -s -8.26 < old.srt > new.srt
  srttidy -b -l "00:00:19,145->00:00:22,189 02:39:17,715->02:39:18,390" my.srt
  srttidy -b -n -d '(yts|sub2smi|elsubtitle)' *.srt
  srttidy -n Movies/*/*.srt
  srttidy -g '(yts|sub2smi|elsubtitle)' *.srt
  srttidy -m 1.0,0.1 my.srt
  # lc: line counts, cc: character counts, du: duration in seconds
  srttidy -f '(lc==1 and cc>15) or cc>20 or du>3.5' < old.srt
  srttidy -m 3,0.1 -f 'cc > 20 and du < 2' my.srt

See <https://github.com/9beach/srt-tools> for updates and bug reports
USAGE

my $QR_BOM = qr/^\x{FEFF}/;
my $QR_DECIMAL = qr/[+-]?\d+\.?\d*/;
my $QR_TIME = qr/[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]/;
my $QR_DURATION = qr/${QR_TIME} *--> *${QR_TIME} *\r?\n/;
my $QR_TIMEMAP = qr/${QR_TIME}->${QR_TIME} +${QR_TIME}->${QR_TIME}/;

sub say { print STDERR shift."\n"; }

my %opts = ();

# Checks the constraints of opts
die $USAGE unless getopts("f:btm:c:rg:d:nl:s:h", \%opts);
die $USAGE if $opts{h};
die $USAGE if (-t STDIN and $#ARGV < 0) or (not -t STDIN and $#ARGV >= 0);
die "Cannot use both -c and -r at the same time\n" if defined $opts{c}
    and defined $opts{r};
die "Cannot use both -s and -l at the same time\n" if defined $opts{s}
    and defined $opts{l};
die "Cannot use -s or -l with multiple files\n" if $#ARGV > 0
    and (defined $opts{s} or defined $opts{l});
die "'$opts{l}' is not valid time-map format\n" if defined $opts{l}
    and not $opts{l} =~ /^${QR_TIMEMAP}$/;
die "'$opts{s}' is not a decimal number\n" if defined $opts{s}
    and not $opts{s} =~ /^${QR_DECIMAL}$/;
die "'$opts{f}' is not valid condition\n" if defined $opts{f}
    and not valid_condition($opts{f});
die "Cannot use -t with the other options\n" if defined $opts{t}
    and (scalar keys %opts > 1);

# Reads from pipe
if ($#ARGV < 0) {
    my $content; { local $/; $content = <STDIN> };
    $content = conv($content);
    die "invalid content\n" unless valid_srt($content);

    $content = tidy($content, %opts);
    print $content;

    exit 0;
}

my $err = 0;

# Reads ARGV files
foreach my $srt (@ARGV) {
    my $nsrt = $srt;
    $nsrt =~ s/\.[^\/\.]*$//;
    $nsrt .= defined $opts{t} ? "-tidy.txt" : "-tidy.srt";

    unless (open(SRT, '<', $srt)) {
        $err = -1;
        say "failed to open: ${srt}";
        next;
    }
    unless (open(NSRT, '>', $nsrt)) {
        $err = -1;
        say "failed to open: ${nsrt}";
        close(SRT);
        next;
    }

    my $content; { local $/; $content = <SRT> };
    $content = conv($content);

    unless (valid_srt($content)) {
        $err = -1;
        say "invalid content: ${srt}";
        next;
    }

    # Shows file name on analysis with -m
    say "tidying: $nsrt" if (defined $opts{m});

    $content = tidy($content, %opts);
    if ($content eq "") {
        say "empty content: ${srt}";
        close(SRT);
        close(NSRT);
        unlink $nsrt;
    } else {
        say "created: ${nsrt}";
        print NSRT $content;
        close(SRT);
        close(NSRT);
    }
}

exit $err;

# Defines submodules below

# Processes the commands
sub tidy {
    my $content = shift;
    my $opts = shift;

    # Removes BOM and CR
    if (defined $opts{b}) {
        $content =~ tr/\r//d;
        $content =~ s/${QR_BOM}//;
    }
 
    # Deletes subtitles including given pattern
    if (defined $opts{d}) {
        for ($content) {
            # \x08, \x09: boundary delimiters for text replacement
            s/(${QR_BOM}?[0-9]+) *(\r?\n)+\s*(${QR_DURATION})
            /\x08$1$2$3\x09/xgm;
            # Removes a subtitle in boundary delimiters if they include pattern
            s/\x08[^\x08]*\x09[^\x08\x09]*${opts{d}}[^\x08]*//gmi;
            tr/\x08\x09//d;
        }
    }

    # Shows subtitles including given pattern
    if (defined $opts{g}) {
        my $buf = $content; $content = "";
        # \x08, \x09: boundary delimiters for text replacement
        $buf =~ s/(${QR_BOM}?[0-9]+) *(\r?\n)+\s*(${QR_DURATION})
                /\x08$1$2$3\x09/xgm;
        while ($buf =~ /\x08[^\x08]*\x09[^\x08\x09]*${opts{g}}[^\x08]*/gmi) {
            $content .= $&;
        }
        $content =~ tr/\x08\x09//d;
    }

    # Shows subtitles matching given condition
    if (defined $opts{f} and not defined $opts{m}) {
        my $expr = $opts{f};
        my $buf = $content; $content = "";
        # \x08, \x09: boundary delimiters for text replacement
        $buf =~ s/${QR_BOM}?([0-9]+) *(\r?\n)+\s*(${QR_DURATION})
                /\x09$1$2$3/xgm;

        while ($buf =~ /
                \x09([0-9]+)(\r?\n)(${QR_TIME})[[:blank:]]*-->[[:blank:]]*
                (${QR_TIME})([^\x09]*)/xgm) {
            if (valid_expr($expr, to_s($4)-to_s($3), $5)) {
                $content .= "$1$2$3 --> $4$5";
            }
        }
        $content =~ tr/\x08\x09//d;
    }
 
    # Removes blank subtitles, and reorder lefts one by one
    if (defined $opts{n}) {
        my $order = 0;
        for ($content) {
            # Removes black lines
            s/^\s*(\r?\n)+//gm;
            # Inserts line before each order
            s/(.)(\r?\n)([0-9]+\s*\n${QR_TIME} *-->)/$1$2$2$3/gm;
            # Removes order and timestamp with blank text
            s/${QR_BOM}?[0-9]+\s*\n${QR_DURATION}((\r?\n)+|\z)//gm;
            # Reorders one by one
            s/${QR_BOM}?[0-9]+ *(\r?\n)+\s*(${QR_DURATION})/${\++$order}$1$2/gm;
        }
    }

    # Displays subtitle texts only
    if (defined $opts{t}) {
        for ($content) {
            s/${QR_BOM}?[0-9]+\s*\r?\n\s*${QR_DURATION}//gm;
            s/<\/? *[a-zA-Z]*[^>]*>//gm;
            s/^\s*//gm;
            s/ +/ /g;
        } 

        # Not srt so return
        return $content;
    }
 
    # Specifies default font color
    if (defined $opts{c}) {
        for ($content) {
            s/<font color[^>]* x=keep-it>//g;
            s/(^${QR_DURATION})([^\r\n])/$1<font color=$opts{c} x=keep-it>$2/gm;
        }
    }

    # Resets specified font colors
    if (defined $opts{r}) {
        $content =~ s/<font color[^>]* x=keep-it>//g;
    }

    # Shift timestamps
    if (defined $opts{s}) {
        my $sec = $opts{s};
        $content =~ s/(${QR_TIME})[[:blank:]]*-->[[:blank:]]*(${QR_TIME})
                    /${\s_shift($1, $sec)} --> ${\s_shift($2, $sec)}/xg;
    }

    # Corrects timestamps linearly
    if (defined $opts{l}) {
        my ($a, $b) = slope_intercept($opts{l});
        $content =~ s/(${QR_TIME})[[:blank:]]*-->[[:blank:]]*(${QR_TIME})
                    /${\l_shift($1, $a, $b)} --> ${\l_shift($2, $a, $b)}/xg;
    }

    # Changes timestamps by given minimum duration and gap, and reports them
    if (defined $opts{m}) {
        my ($md, $mg) = split(",", $opts{m});
        my $ncontent = "";
        my $lf = '\n';
        my $optf = defined $opts{f};
        my $expr = $opts{f};

        for ($content) {
            # Gets my CRLF
            /${QR_BOM}?[0-9]+ *(\r?\n)/m; $lf = $1;
            # Inserts delimiter (\x09) for each order, timestamp, and text
            s/${QR_BOM}?([0-9]+)\s*\n\s*(${QR_DURATION})/\x09$1\n$2/gm;
            # We need dummy last element for time gap
            s/\z/\x091000000\n99:00:00,000 --> 99:59:59,000\n/m;
        }

        my ($porder, $pfrom, $pfrom_s, $pto, $pto_s, $ptext) = ("");

        # Iterates for each delimiter
        while ($content =~ /
                \x09([0-9]+)\n(${QR_TIME})[[:blank:]]*-->[[:blank:]]*
                (${QR_TIME})([^\x09]*)/xgm) {
            my (
                $order, $from, $from_s, $to, $to_s, $text,
            ) = ($1, $2, to_s($2), $3, to_s($3), $4);

            unless ($porder eq "") {
                if (not $optf or valid_expr($expr, $pto_s-$pfrom_s, $ptext)) {
                    $ncontent .= analyze (
                        ($porder, $pfrom, $pfrom_s, $pto, $pto_s, $ptext),
                        ($from, $from_s, $to, $to_s), ($md, $mg, $lf),
                    );
                } else {
                    $ncontent .= "$porder$lf$pfrom --> $pto$ptext";
                }
            }
            ($porder, $pfrom, $pfrom_s, $pto, $pto_s, $ptext) =
                ($order, $from, $from_s, $to, $to_s, $text);
        }

        $content = $ncontent;
    }

    # Removes additional '\n' when final subtitle was empty
    $content =~ s/(\r?\n)+\z/$1/m;
    return $content;
}

# Checks if valid SubRip
sub valid_srt {
    return shift =~ /${QR_BOM}?[0-9]+ *\r?\n\s*${QR_DURATION}/m;
}

sub analyze {
    my (
        $porder, $pfrom, $pfrom_s, $pto, $pto_s, $ptext,
        $from, $from_s, $to, $to_s,
        $md, $mg, $lf,
    ) = @_;

    my $pduration = $pto_s - $pfrom_s;

    # Checks if duration is short, or timestamps are overlapped
    if ($pduration < $md or $pto_s > $from_s) {
        my $state = 'SHORT';
        $state = 'OVERLAPPED' if $pto_s > $from_s;

        my $new_pto_s = 0;

        if ($pfrom_s + $md + $mg < $from_s) {
            if ($state eq 'SHORT') {
                $new_pto_s = $md + $pfrom_s;
            } else {
                $new_pto_s = $from_s - $mg;
            }
            $state .= '/FIXED';
        } elsif ($pto_s + $mg < $from_s) {
            $new_pto_s = $from_s - $mg;
            $state .= '/FIXED BUT SHORT';
        }

        my $sduration;
        if ($new_pto_s) {
            $sduration =
                sprintf('%.3f -> %.3f', $pduration, $new_pto_s - $pfrom_s);
        } else {
            $sduration = sprintf('%.3f', $pduration);
        }

        say_tidy_info(
            $porder,
            "$state ($sduration))",
            "$pfrom --> $pto$ptext",
        );

        if ($new_pto_s) {
            $pto_s = $new_pto_s;
            $pto = to_hms($pto_s * 1000);
        }
    }
    return "$porder$lf$pfrom --> $pto$ptext";
}

sub say_tidy_info {
    say '* '.shift.': '.shift;
    my $text = shift;
    $text =~ s/^/  /mg;
    $text =~ s/\s*\z/\n/m;
    say $text;
}

# Gets slope $a and intercept $b for y = ax + b
sub slope_intercept {
    my $opt = shift;
    my @m = split(/  */, $opt);
    my @t1 = split("->", $m[0]);
    my @t2 = split("->", $m[1]);
    my $t11 = to_s($t1[0]);
    my $t12 = to_s($t1[1]);
    my $t21 = to_s($t2[0]);
    my $t22 = to_s($t2[1]);
    my $a = ($t22 - $t12) / ($t21 - $t11);
    my $b = $t12 - $a * $t11;

    return ($a, $b);
}

# Below, defines submodules
sub s_shift {
    my $t = shift;
    my $s = shift;
    return to_hms((to_s($t) + $s) * 1000);
}

sub l_shift {
    my $t = shift;
    my $a = shift;
    my $b = shift;
    return to_hms((to_s($t) * $a + $b) * 1000);
}

# Decodes to UTF-8
sub conv {
    my $buf = shift;

    if (not utf8::decode $buf) {
        require Encode;
        require Encode::Guess;

        my $decoder = Encode::Guess::guess_encoding($buf, qw/cp949 euc-kr/);
        if (ref($decoder)) {
            $buf = $decoder->decode($buf);
        } else {
            # Fairly often it works
            $buf = Encode::decode("CP949", $buf);
        }
    }
    return $buf;
}

sub to_s {
    my $fmt = shift;
    $fmt =~ s/,/./;
    my @hms = split(":", $fmt);
    return $hms[0] * 3600 + $hms[1] * 60 + $hms[2];
}

sub to_hms {
    my $millisec = shift;
    $millisec = 0 if ($millisec < 0);

    my $seconds = $millisec / 1000;
    my $ms = $millisec % 1000;
    my $s = $seconds % 60;
    my $m = ($seconds / 60) % 60;
    my $h = ($seconds / 3600) % 60;

    return sprintf("%02d:%02d:%02d,%03d", $h, $m, $s, $ms);
}

# Checks if valid condition
sub valid_condition {
    my $condition = shift;
    my $buf = $condition;
    for ($buf) {
        s/\b(or|and|lc|cc|du)\b//gi;
        s/${QR_DECIMAL}//gi;
        s/[ \+\*\/\-()<>=]//gi;
    }

    return 0 unless $buf eq '';

    for ($condition) {
        s/\bcc\b/(-1.324)/gi;
        s/\blc\b/(-9.234762)/gi;
        s/\bdu\b/(0.123124)/gi;
    }
    eval $condition;
    return not $@;
}

sub text_counts {
    my $text = shift;
    for ($text) {
        s/<\/? *[a-zA-Z]*[^>]*>//gm;
        s/^\s*([^\s]*)\s*$/$1/g;
        s/^\s*//gm;
        s/ +/ /g;
        s/\s*\z/\n/m;
    }
    my $lc = $text =~ tr/\n//;
    $text =~ tr/- \r\n!,\.:;—\*"'“”¿?¡!\()\[]<>『』《》｢｣<>≪≫《》〈〉//d;
    my $cc = length($text);
    $lc = 0 if $cc == 0;

    return ($lc, $cc);
}

sub valid_expr {
    my $expr = shift;
    my $du = shift;
    my ($lc, $cc) = text_counts(shift);

    for ($expr) {
      s/\blc\b/($lc)/gi;
      s/\bcc\b/($cc)/gi;
      s/\bdu\b/($du)/gi;
    }

    return eval($expr);
}
